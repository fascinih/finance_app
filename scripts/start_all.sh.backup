#!/bin/bash

# Finance App - Script de InicializaÃ§Ã£o Completa
# Inicia todos os serviÃ§os da aplicaÃ§Ã£o financeira

set -e

# ConfiguraÃ§Ãµes
APP_DIR="/home/ubuntu/finance_app"
VENV_DIR="$APP_DIR/venv"
LOG_DIR="/var/log/finance_app"

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}=== Finance App - InicializaÃ§Ã£o Completa ===${NC}"
echo "Iniciado em: $(date)"

# FunÃ§Ã£o para log
log_message() {
    echo -e "$1"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_DIR/startup.log"
}

# Criar diretÃ³rio de logs se nÃ£o existir
sudo mkdir -p "$LOG_DIR"
sudo chown $USER:$USER "$LOG_DIR"

log_message "${YELLOW}Verificando prÃ©-requisitos...${NC}"

# Verificar se estamos no diretÃ³rio correto
if [ ! -f "$APP_DIR/requirements.txt" ]; then
    log_message "${RED}Erro: DiretÃ³rio da aplicaÃ§Ã£o nÃ£o encontrado em $APP_DIR${NC}"
    exit 1
fi

cd "$APP_DIR"

# Verificar Python e ambiente virtual
if [ ! -d "$VENV_DIR" ]; then
    log_message "${YELLOW}Criando ambiente virtual Python...${NC}"
    python3 -m venv "$VENV_DIR"
fi

# Ativar ambiente virtual
source "$VENV_DIR/bin/activate"

# Atualizar dependÃªncias
log_message "${YELLOW}Verificando dependÃªncias Python...${NC}"
pip install --upgrade pip > /dev/null 2>&1
pip install -r requirements.txt > /dev/null 2>&1

log_message "${GREEN}âœ“ DependÃªncias Python atualizadas${NC}"

# Verificar e iniciar PostgreSQL
log_message "${YELLOW}Verificando PostgreSQL...${NC}"

if ! systemctl is-active --quiet postgresql; then
    log_message "${YELLOW}Iniciando PostgreSQL...${NC}"
    sudo systemctl start postgresql
    sleep 3
fi

if systemctl is-active --quiet postgresql; then
    log_message "${GREEN}âœ“ PostgreSQL ativo${NC}"
else
    log_message "${RED}Erro: NÃ£o foi possÃ­vel iniciar PostgreSQL${NC}"
    exit 1
fi

# Verificar banco de dados
if psql -U finance_user -d finance_app -c '\q' 2>/dev/null; then
    log_message "${GREEN}âœ“ Banco de dados acessÃ­vel${NC}"
else
    log_message "${YELLOW}Configurando banco de dados...${NC}"
    
    # Executar script de configuraÃ§Ã£o do banco
    if [ -f "scripts/setup_database.sh" ]; then
        bash scripts/setup_database.sh
    else
        log_message "${RED}Erro: Script de configuraÃ§Ã£o do banco nÃ£o encontrado${NC}"
        exit 1
    fi
fi

# Verificar e iniciar Redis
log_message "${YELLOW}Verificando Redis...${NC}"

if ! systemctl is-active --quiet redis-server; then
    log_message "${YELLOW}Iniciando Redis...${NC}"
    sudo systemctl start redis-server
    sleep 2
fi

if systemctl is-active --quiet redis-server; then
    log_message "${GREEN}âœ“ Redis ativo${NC}"
else
    log_message "${RED}Erro: NÃ£o foi possÃ­vel iniciar Redis${NC}"
    exit 1
fi

# Verificar Ollama
log_message "${YELLOW}Verificando Ollama...${NC}"

if ! pgrep -x "ollama" > /dev/null; then
    log_message "${YELLOW}Iniciando Ollama...${NC}"
    
    # Tentar iniciar Ollama em background
    nohup ollama serve > "$LOG_DIR/ollama.log" 2>&1 &
    sleep 5
    
    if pgrep -x "ollama" > /dev/null; then
        log_message "${GREEN}âœ“ Ollama iniciado${NC}"
    else
        log_message "${YELLOW}âš  Ollama nÃ£o disponÃ­vel (opcional)${NC}"
    fi
else
    log_message "${GREEN}âœ“ Ollama jÃ¡ estÃ¡ rodando${NC}"
fi

# Verificar se hÃ¡ modelo Ollama disponÃ­vel
if pgrep -x "ollama" > /dev/null; then
    MODELS=$(ollama list 2>/dev/null | grep -v "NAME" | wc -l)
    if [ "$MODELS" -eq 0 ]; then
        log_message "${YELLOW}Nenhum modelo Ollama encontrado. Baixando modelo padrÃ£o...${NC}"
        ollama pull llama2 > /dev/null 2>&1 &
        log_message "${BLUE}Download do modelo iniciado em background${NC}"
    else
        log_message "${GREEN}âœ“ $MODELS modelo(s) Ollama disponÃ­vel(is)${NC}"
    fi
fi

# Parar serviÃ§os existentes se estiverem rodando
log_message "${YELLOW}Parando serviÃ§os existentes...${NC}"

# Parar FastAPI
if pgrep -f "uvicorn.*finance_app" > /dev/null; then
    pkill -f "uvicorn.*finance_app"
    sleep 2
    log_message "${BLUE}FastAPI anterior parado${NC}"
fi

# Parar Streamlit
if pgrep -f "streamlit.*finance_app" > /dev/null; then
    pkill -f "streamlit.*finance_app"
    sleep 2
    log_message "${BLUE}Streamlit anterior parado${NC}"
fi

# Iniciar FastAPI
log_message "${YELLOW}Iniciando FastAPI...${NC}"

nohup python -m uvicorn src.api.main:app --host 0.0.0.0 --port 8000 --reload > "$LOG_DIR/fastapi.log" 2>&1 &
FASTAPI_PID=$!

# Aguardar FastAPI inicializar
sleep 5

# Verificar se FastAPI estÃ¡ rodando
if curl -s http://localhost:8000/api/v1/health > /dev/null 2>&1; then
    log_message "${GREEN}âœ“ FastAPI iniciado (PID: $FASTAPI_PID)${NC}"
else
    log_message "${RED}Erro: FastAPI nÃ£o respondeu${NC}"
    
    # Mostrar logs de erro
    if [ -f "$LOG_DIR/fastapi.log" ]; then
        log_message "${YELLOW}Ãšltimas linhas do log do FastAPI:${NC}"
        tail -10 "$LOG_DIR/fastapi.log"
    fi
    
    exit 1
fi

# Iniciar Streamlit
log_message "${YELLOW}Iniciando Streamlit...${NC}"

nohup streamlit run streamlit_app.py --server.port 8501 --server.address 0.0.0.0 > "$LOG_DIR/streamlit.log" 2>&1 &
STREAMLIT_PID=$!

# Aguardar Streamlit inicializar
sleep 8

# Verificar se Streamlit estÃ¡ rodando
if netstat -tuln | grep -q ":8501"; then
    log_message "${GREEN}âœ“ Streamlit iniciado (PID: $STREAMLIT_PID)${NC}"
else
    log_message "${RED}Erro: Streamlit nÃ£o respondeu${NC}"
    
    # Mostrar logs de erro
    if [ -f "$LOG_DIR/streamlit.log" ]; then
        log_message "${YELLOW}Ãšltimas linhas do log do Streamlit:${NC}"
        tail -10 "$LOG_DIR/streamlit.log"
    fi
    
    exit 1
fi

# Executar verificaÃ§Ãµes de saÃºde
log_message "${YELLOW}Executando verificaÃ§Ãµes de saÃºde...${NC}"

# Testar API
API_HEALTH=$(curl -s http://localhost:8000/api/v1/health | jq -r '.status' 2>/dev/null || echo "error")
if [ "$API_HEALTH" = "healthy" ]; then
    log_message "${GREEN}âœ“ API Health Check: OK${NC}"
else
    log_message "${YELLOW}âš  API Health Check: $API_HEALTH${NC}"
fi

# Salvar PIDs para controle
echo "$FASTAPI_PID" > "$LOG_DIR/fastapi.pid"
echo "$STREAMLIT_PID" > "$LOG_DIR/streamlit.pid"

# Mostrar resumo
log_message "${BLUE}=== Resumo da InicializaÃ§Ã£o ===${NC}"
log_message "${GREEN}âœ“ PostgreSQL: Ativo${NC}"
log_message "${GREEN}âœ“ Redis: Ativo${NC}"

if pgrep -x "ollama" > /dev/null; then
    log_message "${GREEN}âœ“ Ollama: Ativo${NC}"
else
    log_message "${YELLOW}âš  Ollama: NÃ£o disponÃ­vel${NC}"
fi

log_message "${GREEN}âœ“ FastAPI: http://localhost:8000 (PID: $FASTAPI_PID)${NC}"
log_message "${GREEN}âœ“ Streamlit: http://localhost:8501 (PID: $STREAMLIT_PID)${NC}"

# Mostrar URLs de acesso
echo ""
log_message "${BLUE}=== URLs de Acesso ===${NC}"
log_message "${YELLOW}Interface Web (Streamlit): http://localhost:8501${NC}"
log_message "${YELLOW}API Backend (FastAPI): http://localhost:8000${NC}"
log_message "${YELLOW}DocumentaÃ§Ã£o da API: http://localhost:8000/docs${NC}"

# Mostrar comandos Ãºteis
echo ""
log_message "${BLUE}=== Comandos Ãšteis ===${NC}"
log_message "${YELLOW}Parar todos os serviÃ§os: bash scripts/stop_all.sh${NC}"
log_message "${YELLOW}Monitorar sistema: bash scripts/monitor_system.sh${NC}"
log_message "${YELLOW}Backup do banco: bash scripts/backup_database.sh${NC}"
log_message "${YELLOW}Ver logs: tail -f $LOG_DIR/*.log${NC}"

# Configurar monitoramento automÃ¡tico (opcional)
if [ -f "scripts/monitor_system.sh" ]; then
    log_message "${YELLOW}Configurando monitoramento automÃ¡tico...${NC}"
    
    # Adicionar ao crontab se nÃ£o existir
    if ! crontab -l 2>/dev/null | grep -q "monitor_system.sh"; then
        (crontab -l 2>/dev/null; echo "*/15 * * * * $APP_DIR/scripts/monitor_system.sh > /dev/null 2>&1") | crontab -
        log_message "${GREEN}âœ“ Monitoramento automÃ¡tico configurado (a cada 15 minutos)${NC}"
    fi
fi

log_message "${GREEN}=== InicializaÃ§Ã£o ConcluÃ­da com Sucesso ===${NC}"
log_message "Finalizado em: $(date)"

echo ""
echo -e "${GREEN}ðŸŽ‰ Finance App iniciado com sucesso!${NC}"
echo -e "${BLUE}Acesse http://localhost:8501 para usar a aplicaÃ§Ã£o${NC}"

